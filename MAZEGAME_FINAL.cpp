#include <iostream>
#include <conio.h>
#include "time.h"
#include "windows.h"
#include "CrtLib.h"

using namespace std;
using namespace crt;

const int LX = 75;
const int LY = 30;
const char player = (char)253;
// 0 - пустое пространство
// 1 - стена
// 2 - выход
// 3 - игрок
// 4 - монета

int maze[LY][LX] = {
{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
{1,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
{1,8,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,8,0,7,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
{1,0,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,0,1,1,1,1,1,1,6,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
{1,5,1,1,0,1,1,1,0,0,4,0,5,0,0,1,1,0,1,1,1,1,0,1,1,1,1,1,1,0,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
{1,0,1,1,0,1,1,1,1,1,1,1,1,1,0,1,1,0,1,1,1,1,0,1,1,1,1,1,1,0,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,6,0,0,8,0,0,0,0,0,0,4,0,5,0,0,6,0,8,0,0,1},
{1,1,1,1,0,1,1,1,1,1,1,1,1,1,8,1,1,0,1,1,1,1,0,1,1,1,1,1,1,5,1,1,5,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4,1},
{1,8,1,1,0,1,1,0,0,0,5,0,6,0,0,1,1,0,1,1,1,1,0,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,0,1},
{1,5,1,1,0,1,1,1,1,1,1,1,1,1,0,1,1,0,1,1,1,1,4,1,1,1,1,1,1,1,1,1,8,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,7,1},
{1,0,1,1,0,1,1,1,1,1,1,1,1,1,7,1,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,0,0,0,4,0,0,0,0,7,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,0,1},
{1,4,1,1,0,1,1,1,1,1,1,1,1,1,6,1,1,0,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,0,0,0,8,0,6,0,0,6,0,0,4,5,0,0,1,1,1,1,1},
{1,0,1,1,0,1,1,1,1,1,1,1,1,1,0,1,1,0,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,1,1,1,0,0,0,0,0,0,5,0,0,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,4,0,1,1},
{1,5,1,1,0,0,0,0,0,0,0,0,0,1,8,1,1,0,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
{1,0,1,1,0,1,1,1,1,1,1,1,0,1,0,1,1,0,1,1,1,1,1,1,1,1,1,1,0,1,1,1,0,0,5,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,2},
{1,0,1,1,4,1,1,1,1,1,1,1,0,1,4,1,1,0,1,1,1,1,1,1,1,1,1,1,0,1,1,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1},
{1,0,1,1,0,1,1,1,1,1,1,1,0,1,0,1,1,0,0,0,0,0,0,0,0,0,0,1,0,1,1,1,0,1,1,1,1,1,1,0,1,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,1,1,1,1,1,1,0,0,0,4,0,0,1},
{1,0,1,1,1,1,1,1,1,1,1,1,0,1,6,1,1,0,1,1,1,1,1,1,1,1,0,1,0,1,1,1,0,0,8,0,0,6,1,0,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1},
{1,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,0,1,1,1,1,1,1,1,1,0,1,0,1,1,1,0,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1},
{1,5,6,0,1,1,1,0,0,0,0,1,0,1,1,1,1,0,1,1,1,1,1,1,1,1,0,1,0,1,1,1,0,8,0,0,5,0,0,6,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1},
{1,1,1,0,1,1,1,0,1,1,0,1,0,1,1,1,1,0,1,1,1,0,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1},
{1,1,1,0,1,1,1,5,1,1,0,1,0,1,1,1,1,0,1,1,1,0,1,1,1,1,0,1,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,8,0,0,0,5,0,0,6,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1},
{1,1,1,0,1,1,1,0,1,1,0,1,0,1,1,1,1,0,0,0,1,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1},
{1,1,1,8,1,1,1,0,1,1,0,1,0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1},
{1,1,1,0,1,1,1,0,1,1,0,1,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,0,1,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1},
{1,1,1,7,1,1,1,0,1,1,0,0,0,1,1,1,1,1,1,1,1,7,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,5,1,1,5,1,1,1,1,1,1,0,1,1,1,1,1,1,7,1,1,1,1,1,1,0,1},
{1,1,1,0,0,0,0,4,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,0,1,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,5,1},
{1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,6,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,0,0,8,0,1,1,1,1,1,1,0,1,1,1,1,1,1,8,1,1,1,1,1,1,0,1},
{1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,6,0,0,0,0,0,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,4,1},
{1,1,1,3,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,8,0,4,0,0,5,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,0,0,5,0,0,0,6,8,1},
{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
};

// глобальные переменные
HANDLE hStdOut = GetStdHandle(STD_OUTPUT_HANDLE); // подключаем библиотеку для цвета
int hx, hy; // позиция игрока в лабиринте
int score = 0; // счет игры

int gameState = 0; // 0 - игра продолжается, 1 - выигрыш, 2 - закончилось время
int timeLimit = 50; // лимит игры в секундах
int gameTime; // оставшееся время

clock_t tstart; // значение счетчика таймера при старте игры

// Функция обновляет текущий счет на экране
void UpdateScore(int score)
{
	GotoXY(35, 30); // ставим курсор на последнюю строку консоли
	setlocale(LC_ALL, "ru-RU"); // включаем локаль, ориентированную на кириллицу
	SetTextColor(COLOR_LIGHT_BLUE); // счетчик очков перекрашиваем в ярко-синий цвет
	cout << "СЧЕТ: " << score; // выводим счет на экран
	setlocale(LC_ALL, "C"); // возвращаем настройки локали по умолчанию
}


void UpdateClock(clock_t t)
{
	gameTime = timeLimit - (t - tstart) / CLOCKS_PER_SEC; /* вычисляем оставшееся время в секундах
	и помещаем результат в gameTime. (t-tstart) - кол-во миллисекунд, прошедшее
	с момента старта игры. CLOCKS_PER_SEC - константа, определяющая количество
	изменений системного таймера за 1 секунду. Для Windows это значение
	равно 1000. Вычитая из timeLimit время, прошедшее с начала игры, мы вычисляем
	остаток времени в секундах */
	setlocale(LC_ALL, "ru-RU"); // переключаем локаль
	if (gameTime < 0) // проверяем, закончилось ли время
	{
		gameState = 2; // если да, то обновляем статус игры на 2 - игрок ПРОИГРАЛ
	}
	else
	{ // если время осталось
		GotoXY(49, 30); // ставим курсор на последнюю строку
		SetTextColor(COLOR_LIGHT_GREEN);
		if (gameTime > 15) // условие для вывода в консоль времени если его больше 15 секунд
		{
			SetTextColor(COLOR_LIGHT_GREEN); // задаем цвет счетчику времени 
			cout << "Осталось: " << gameTime << " секунд "; // выводим остаток времени в консоль
		}
		else
		{
			SetTextColor(COLOR_RED); // при условии что времени меньше 15, цвет красный
			cout << "Осталось: " << gameTime << " секунд "; // выводим остаток времени в консоль
		}
	}
	setlocale(LC_ALL, "C"); // восстанавливаем настройки локали
}
// Функция обновляет оставшееся время до окончания игры
// параметр t функции - это текущее значение системного таймера, на момент вызова функции

void ShowGameOverMessage()
{
	setlocale(LC_ALL, "ru-RU");
	cout << "ПОБЕДА СО СЧЁТОМ : " << score << " ОЧКОВ.";
	setlocale(LC_ALL, "C");
}
void ShowGameTimeOverMessage()
{
	setlocale(LC_ALL, "ru-RU");
	cout << "ПРОИГРЫШ СО СЧЁТОМ : " << score << " ОЧКОВ.";
	setlocale(LC_ALL, "C");
}


// Функция печатает в консоли лабиринт
void PrintMaze(int maze[LY][LX], int sizeX, int sizeY)
{
	for (int i = 0; i < sizeY; i++)
	{
		for (int j = 0; j < sizeX; j++)
		{
			switch (maze[i][j])
			{
			case 0:
				cout << ' ';
				break;
			case 1:
				SetTextColor(COLOR_LIGHT_RED); // задаем цвет стене красный
				cout << (char)178;
				break;
			case 2:
				SetTextColor(COLOR_LIGHT_CYAN); // задаем цвет выходу серый
				cout << (char)176;
				break;
			case 3:
				SetTextColor(COLOR_WHITE);  // задаем цвет игроку белый
				cout << player;
				break;
			case 4:
				SetTextColor(COLOR_YELLOW); // задаем цвет знаку $ желтый
				cout << '$';
				break;
			case 5:
				SetTextColor(COLOR_LIGHT_BLUE);
				cout << (char)1742;
				break;
			case 6:
				SetTextColor(COLOR_LIGHT_MAGENTA);
				cout << (char)79;
				break;
			case 7:
				SetTextColor(COLOR_DARK_GRAY);
				cout << (char)248;
				break;
			case 8:
				SetTextColor(COLOR_DARK_GRAY);
				cout << (char)248;
				break;
			default:
				cout << '?';
			}
		}
		cout << endl;
	}
}
//Функция скрывает игрока с экрана и убирает его из лабиринта
void HidePlayer()
{
	maze[hy][hx] = 0; // записываем в текущую позицию матрицы число 0
	GotoXY(hx, hy); // устанавливаем курсор в позицию игрока в консоль
	cout << ' '; // и печатаем пробел
}

// функция показывает на экране игрока и записывает его в лабиринт
void ShowPlayer()
{
	maze[hy][hx] = 3; // записываем в текущую позицию матрицы число 0
	GotoXY(hx, hy); // устанавливаем курсор в позицию игрока в консоль
	SetTextColor(COLOR_WHITE); // задаем цвет игрока белый, чтобы он при каждом ходе обновлялся
	cout << player; // и печатаем образ игрока
}

// Функция перемещает игрока вверх на одну клетку, если это разрешено
void MovePlayer(int dx, int dy)
{
	if (hx + dx < LX && hy + dy < LY && hx + dx >= 0 && hy + dy >= 0) {
		switch (maze[hy + dy][hx + dx])
		{
		case 0: // Пустая ячейка
			HidePlayer();
			hx += dx; // Перемещение по X
			hy += dy; // Перемещение по Y
			ShowPlayer();
			break;
		case 2: // Выход
			HidePlayer();
			hx += dx;
			hy += dy;
			ShowPlayer();
			UpdateScore(score += 500); // Бонус за выход
			gameState = 1; // Изменение статуса игры на выигрыш
			break;
		case 4: // Монета
			HidePlayer();
			hx += dx;
			hy += dy;
			ShowPlayer();
			UpdateScore(score += 100); // Бонус за монету
			break;
		case 5: // Другой предмет
			HidePlayer();
			hx += dx;
			hy += dy;
			ShowPlayer();
			UpdateScore(score += 300); // кейс 5 добавляет 300 очков
			break;
		case 6: // Таймер
			HidePlayer();
			hx += dx;
			hy += dy;
			ShowPlayer();
			UpdateClock(timeLimit += 10); // добавляем при поднятии кейса 6 время на 10с.
			break;
		case 7:
			HidePlayer();
			hx += dx;
			hy += dy;
			ShowPlayer();
			UpdateScore(score -= 200 & score >> 0); // задаем значение при котором мина 7 будет отнимать 200 очков, при этом очки не должны уходить в отрицательное значение
			break;
		case 8:
			HidePlayer();
			hx += dx;
			hy += dy;
			ShowPlayer();
			UpdateClock(timeLimit -= 8); // задаем значение при котором мина 8 будет отнимать 8 секунд времени
			break;
		}
	}
}


// Функция обрабатывает события клавиатуры и управляет игрой
void Control()
{
	tstart = clock(); // запоминаем счетчик системного таймера в момент старта игры.
	UpdateScore(score); // обновляем счет игры, изначально он нулевой
	unsigned char x; // это переменная хранит символ, соответствующий нажатой клавише
	while (gameState == 0) // цикл игры - пока gameState == 0, игра идет
	{
		UpdateClock(clock()); // обновляем оставшееся время
		if (_kbhit()) // если была нажата клавиша - то обрабатываем ее, иначе следующая
		{ // итерация игрового цикла
			x = _getch(); // считываем символ нажатой клавиш,
			if (x == 27) return;// если это символ Esc (27) то это выход из игры
			if (x == 0xe0) // если это символ с кодом 0xE0 (шестнадцатеричное)
				switch (_getch()) // то считываем еще один символ (некоторые клавиши выдают двойные коды)
				{
				case 72: // если 2-й символ код 72, то это клавиша курсор вверх
					MovePlayer(0, -1); // идем вверх
					break;
				case 80: // если 2-й символ код 80, то это клавиша курсор вниз
					MovePlayer(0, +1); // идем вниз
					break;
				case 75: // если 2-й символ код 75, то это клавиша курсор влево
					MovePlayer(-1, 0); // идем влево
					break;
				case 77:
					MovePlayer(1, 0); // если 2 - й символ код 77, то это клавиша курсор вправо
					break; // идем вправо
				}
		}
		Sleep(200); // останавливаем игру на 200 мсек, если этого не делать, то
	}
	if (gameState == 1 && gameTime > 1)
	{
		SetTextColor(COLOR_YELLOW);
		GotoXY(20, 15);
		cout << "===================================";
		GotoXY(20, 17);
		cout << "===================================";
		GotoXY(20, 16);
		cout << "|  ";
		GotoXY(52, 16);
		cout << "  |";
		GotoXY(23, 16);
		SetTextColor(COLOR_LIGHT_GREEN);
		ShowGameOverMessage;
	}
	else
	{
		SetTextColor(COLOR_YELLOW);
		GotoXY(20, 15);
		cout << "===================================";
		GotoXY(20, 17);
		cout << "===================================";
		GotoXY(20, 16);
		cout << "|  ";
		GotoXY(52, 16);
		cout << "  |";
		GotoXY(23, 16);
		SetTextColor(COLOR_LIGHT_RED);
		ShowGameTimeOverMessage;
	}
	// обновление игры будет слишком быстрым, мы не сможем управлять
} // игроком, а также напрасно нагрузим процессор ненужной работой
void clearScreen() {
	system("cls"); // очищаем экран
}
// Функция определяет позицию игрока в массиве, обновляя значения глобальных переменных hx и hy
bool FindFirstPlayerPosition(int maze[LY][LX], int sizeX, int sizeY)
{
	int search_player = 0; // счетчик для количества вхождений игрока
	int search_finish = 0; // счетчик для количества вхождений выхода

	for (int i = 0; i < sizeY; ++i) {
		for (int j = 0; j < sizeX; ++j) {
			if (maze[i][j] == 3) { // Если элемент равен 3 - нашли игрока
				hx = j; // Записываем координаты игрока
				hy = i;
				search_player++;
			}
			else if (maze[i][j] == 2) { // Если элемент равен 2 - нашли выход
				hx = j; // Записываем координаты игрока
				hy = i;
				search_finish++;
			}
		}
	}

	return (search_finish > 0 && search_player == 1); // Возвращаем true, если один игрок и хотя бы один выход
}

// Функция main, которая выполняется при запуске программы
int main()
{
	if (FindFirstPlayerPosition(maze, LX, LY)) // при условии валидации лабиринта выполняются следующие команды:
	{
		system("mode con cols=80 lines=31");
		system("cls");
		PrintMaze(maze, LX, LY);
		UpdateClock(clock());
		HideCursor();
		Control();
		if (gameTime > 1)
		{
			ShowGameOverMessage();
		}
		else
		{
			ShowGameTimeOverMessage();
		}
		ShowCursor();
		GotoXY(74, 30);
		_getch();
	}
	else { // если лабиринт не валиден
		setlocale(LC_ALL, "ru-Ru");
		system("cls");
		SetTextColor(COLOR_RED);
		cout << "Лабиринт не прошел валидацию" << endl;
	}
}